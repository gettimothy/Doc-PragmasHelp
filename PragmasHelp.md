# Table of Contents1.  [Pragmas](#org04deb25)    1.  [Introduction](#org75b99bc)    2.  [Pragma Basics](#orgf34d23d)    3.  [Pragma Uses](#orga9c72df)    4.  [A Pattern that Works](#org1b81c50)    5.  [How Pragmas for Menus Should Be Done](#orge4d4926)    6.  [Pragmas in Senders Of](#org8b51c3a)    7.  [Pragmas in Xtreams Parsing](#org13384d3)    8.  [Common Methods](#orgb579c3d)<a id="org04deb25"></a># Pragmas<a id="org75b99bc"></a>## Introduction    This help is per Eliot Miranda's comments on Pragmas from an email exchange on Squeak-Dev              "Many see pragmas as labels.  But they are executable.  With pragmas, to label is human, to execute is divine."<a id="orgf34d23d"></a>## Pragma Basics    todo<a id="orga9c72df"></a>## Pragma Uses    todo<a id="org1b81c50"></a>## A Pattern that Works    1. Create a builder object that understnds the pragma(s) in question    2. Visit the method(s) implementing the pragma    3. Send the pragma to the builder<a id="orge4d4926"></a>## How Pragmas for Menus Should Be Done    1. Give the base menu to a menudecorator builder which is parameterized with the name of the menu and class(es) involved in the menu.    2. Have the menu decorator builder visit the relevant pragma methods in the class(es)    3. Use the resulting decorated menu.<a id="org8b51c3a"></a>## Pragmas in Senders Ofdiscusson of the code behind the 'Senders' button on the Browser<a id="org13384d3"></a>## Pragmas in Xtreams Parsing        In the XTreams-parsing application that processes this document, we use a Pragma to associate a callback with one or more grammar rules.        The rules that handle '** Stuff Like This [optionalselector]...' handle 1 to eight '*' and are defined below.            	HeadlineItem1 	<- ^STAR{1} s HeadLineText  Paragraph*    	HeadlineItem2 	<- ^STAR{2} s HeadLineText  Paragraph*    	HeadlineItem3	<- ^STAR{3} s HeadLineText  Paragraph*    	HeadlineItem4	<- ^STAR{4} s HeadLineText  Paragraph*    	HeadlineItem5	<- ^STAR{5} s HeadLineText  Paragraph*    	HeadlineItem6	<- ^STAR{6} s HeadLineText  Paragraph*    	HeadlineItem7	<- ^STAR{7} s HeadLineText  Paragraph*	    	HeadlineItem8	<- ^STAR{8} s HeadLineText  Paragraph*                 When the parser matches a pattern, we can associate a callback that will be executed when the match occurs.    Below is the callback for the HeadlineItem rules above.                HeadlineItem:  starOrderedCollection topic: aHelpTopic content: anOrderedCollection                	<action: 'HeadlineItem1' arguments: #(2 4 5)>    	<action: 'HeadlineItem2' arguments: #(2 4 5)>    	<action: 'HeadlineItem3' arguments: #(2 4 5)>    	<action: 'HeadlineItem4' arguments: #(2 4 5)>    	<action: 'HeadlineItem5' arguments: #(2 4 5)>    	<action: 'HeadlineItem6' arguments: #(2 4 5)>    	<action: 'HeadlineItem7' arguments: #(2 4 5)>    	<action: 'HeadlineItem8' arguments: #(2 4 5)>            	|ht  index ios |    	index := starOrderedCollection size.	    	ht := aHelpTopic.    	ios := (String streamContents:    				[ : stream |    					paragraphcache do:[:each |     						stream nextPutAll: each.    						]]).	    	ht contents: (ios contents).	    	ht priority: index.	    	(helptopiccache at: index) addLast: ht.	    	paragraphcache := OrderedCollection new.    	transcripton ifTrue:[Transcript show:'HeadlineItem', (index asString) , '->' , (ht key);cr.	].	    	^ht        Note that more than one Pragma can be placed in a callback. And that this one method handles all the rules.        In Xtreams-Parsing, look at any of the subclasses of PEGActor for the callbacks.    To see the Grammars for those callbacks, look at the class side of PEGParser.<a id="orgb579c3d"></a>## Common Methods    perform: withArguments:    sendTo:     sendMessage: 